# 데이터 모델
앞서 데이터베이스의 정의를 데이터를 구조적으로 보관하고 이 데이터들을 관리하는 시스템이라고 정의했습니다. 이때 데이터를 구조적으로 보관하는 방법을 데이터 모델이라고 합니다. 데이터 모델은 데이터베이스를 설계할 때 고려할 부분이며, 데이터베이스의 구조를 정의하고 데이터들 간의 관계를 정의합니다.

데이터 모델을 이해하기 위해 프로그래밍에서 자주 사용되는 스택(Stack) 구조를 예로 들어보겠습니다.

1. 구조 (Structure): 스택은 FILO(First In, Last Out) 구조를 가집니다.
2. 연산 (Operations): 스택에는 push(삽입)와 pop(삭제) 연산이 있습니다.
3. 제약조건 (Constraints): 스택에는 정수만 넣을 수 있다고 가정해 봅시다.

이처럼 스택을 정의할 때 구조, 연산, 제약조건을 명확히 하는 것처럼, 데이터베이스를 설계할 때도 비슷한 개념이 적용됩니다.
데이터베이스의 데이터 모델을 정의할 때는 다음과 같은 요소를 고려합니다.

1. 구조 (Structure): 데이터가 어떤 형태로 저장되는지 정의합니다. 예를 들어, 테이블, 문서, 그래프 등의 형태가 있습니다.
2. 연산 (Operations): 데이터를 어떻게 조작할 수 있는지 정의합니다. 삽입, 조회, 수정, 삭제 등의 연산이 여기에 해당합니다.
3. 제약조건 (Constraints): 데이터의 무결성을 유지하기 위한 규칙을 정의합니다. 예를 들어, 특정 필드에는 고유한 값만 허용하거나, 다른 테이블의 데이터를 참조하는 등의 제약을 둘 수 있습니다.

이렇게 데이터 모델을 정의함으로써, 데이터베이스 설계자와 사용자는 데이터의 구조와 의미를 명확히 이해하고, 효율적으로 데이터를 관리할 수 있게 됩니다. 하지만 이러한 데이터 모델을 관리자가 직접 제어할 일은 거의 없습니다. DBMS가 내부적으로 데이터 모델을 관리하고, 사용자가 데이터를 쉽게 조작할 수 있도록 도와줍니다.

데이터 모델의 발전과정을 살표보겠습니다.
1. 계층 데이터 모델(Hierarchical Data Model): 1960 ~ 1970
    * 트리 구조를 사용하여 데이터 간의 관계를 표현
2. 네트워크 데이터 모델(Network Data Model): 1970 ~ 1980
    * 계층 모델의 한계를 극복하기 위해 더 복잡한 관계 표현 가능
3. 관계 데이터 모델(Relational Data Model): 1980 ~ 현재
    * 테이블 형태로 데이터를 저장하고 SQL을 통해 데이터 조작
4. 객체 데이터 모델(Object Data Model): 1990 ~ 2000
    * 객체지향 프로그래밍 개념을 데이터베이스에 적용
5. 객체-관계 데이터 모델(Object-Relational Data Model): 2000 ~ 현재
    * 관계 모델과 객체 모델의 장점을 결합

이렇게 여러 데이터 모델들이 있었지만 현재는 관계 데이터 모델이 주로 사용되고 있습니다. 관계 데이터 모델은 단순하면서도 강력한 데이터 표현 능력, 뛰어난 확장성, 그리고 SQL이라는 표준화된 질의 언어 덕분에 널리 채택되었습니다. 객체-관계 데이터 모델도 가끔 사용되지만 그 빈도는 매우 낮습니다.

최근에는 대용량 데이터 처리를 위한 NoSQL 데이터베이스 등 새로운 형태의 데이터 모델도 등장하고 있지만, 이 책에서는 가장 널리 사용되는 관계 데이터 모델에 초점을 맞추어 다루도록 하겠습니다.

***

# 관계 데이터 모델
관계 데이터 모델은 데이터를 엑셀 스프레드시트와 유사한 형태의 행과 열로 이루어진 표로 표현합니다. 이러한 표를 관계(relation), 테이블(table), 또는 스키마(schema)라고 부릅니다.

이 세 용어는 맥락에 따라 비슷한 의미로 사용되기도 하지만, 실무에서는 'table'이라는 용어가 가장 많이 사용되며, 이 책에서도 주로 'table'이라는 용어를 사용하겠습니다.

다만, 일부 DBMS에서는 schema와 table을 구분하여 사용하기도 합니다. 이 경우, 각각의 표를 table이라고 부르고, 이러한 table들이 모여 schema를 이루며, schema들이 모여 전체 데이터베이스를 구성한다고 설명합니다.

## Table
[좀더 자세한 그림 필요]

| id | name | age |
|----|------|-----|
| 1  | Alice| 24  |
| 2  | Bob  | 25  |
| 3  | Chris| 23  |

위의 테이블 예시를 통해 관계형 데이터베이스의 주요 구성 요소를 설명하겠습니다.

1. 튜플(Tuple): Table의 각 행을 튜플이라고 부릅니다.
    * (1, 'Alice', 24), (2, 'Bob', 25), (3, 'Chris', 23)
2. 속성(Attribute): 테이블의 최상단 행에 있는 제목을 속성이라 합니다.
    * id, name, age
3. 도메인(Domain): 속성이 가질 수 있는 값의 타입을 의미합니다.
    * id는 정수, name은 문자열, age는 정수
4. 인스턴스(Instance): 튜플의 집합, 즉 테이블에 저장된 데이터의 전체 집합을 인스턴스라고 부릅니다.
    * 위 테이블의 모든 행을 포함한 전체가 하나의 인스턴스입니다. 이는 수시로 변화하는 데이터입니다.
5. 스키마(Schema): 테이블의 구조를 정의하는 것, 혹은 속성의 집합을 의미합니다. 일반적으로 데이터베이스를 설계한다는 것은 이 스키마를 설계한다는 것과 같습니다.
    * (id: Integer, name: String, age: Integer)가 스키마입니다.
6. 차수(degree): 속성의 개수
    * 위 테이블의 차수는 3입니다.
7. 카디널리티(Cardinality): 튜플의 개수
    * 위 테이블의 카디널리티는 3입니다.

### Table의 특징
테이블의 특징을 몇 가지 살펴보겠습니다. 이는 직관적으로 한 번에 이해할 수 있도록 설계되어 있고 무엇보다 DBMS가 알아서 해주기 때문에 신경쓸일 또한 없습니다. 그냥 이러한 개념이 있다고만 알아두셔도 괜찮습니다. 역시 이러한 특징들은 SQL로 생성, 조작됩니다.

1. 속성은 단일 값을 가져야 합니다.
    * 각 속성의 값은 도메인에 정의된 값만을 가지며 그 값은 모두 단일 값이어야 합니다. (Alice, Bob)은 잘못된 속성이고 (Alice), (Bob)이 올바른 속성입니다.
2. 속성은 서로 다른 이름을 가져야 합니다.
    * 속성은 한 Table에서 서로 다른 이름을 가져야만 합니다.
3. 한 속성의 값은 모두 같은 도메인 값을 가져야 합니다.
    * 한 속성에 속한 열은 모두 그 속성에 정의한 도메인 값만 가질 수 있습니다. 예를 들어, 한 속성에는 `int`만, 다른 속성에는 `string`만 등이 가능합니다.
4. 속성의 순서는 상관 없습니다.
    * 속성의 순서가 바뀌어도 같은 테이블입니다. (id, name, age)와 (name, id, age)는 같은 테이블입니다.
5. 튜플의 순서가 바뀌어도 같은 테이블입니다.
6. Table 내의 중복된 튜플은 허용하지 않습니다.

[TODO: 잘못된 테이블 예시 그림 필요]


## Relationship
관계(Relationship)는 데이터베이스 설계에서 중요한 개념으로, 크게 두 가지로 나눌 수 있습니다.

[자세한 그림 필요]

### Tuple 내 데이터들의 관계
하나의 튜플 내에서 각 속성 간의 논리적 연관성을 의미합니다. 예를들어, **학생**테이블에서 `학번`, `이름`, `학과` 속성은 모두 한 학생을 설명하는 데 사용됩니다. 이 관계는 테이블 설게시 자연스럽게 형성되며, 실제 데이터베이스 운영에서는 이 관계를 특별히 신경 쓸 일은 없습니다.

### Table 간에 생성되는 관계
이는 관계형 데이터베이스의 핵심 개념으로, 서로 다른 테이블 간의 논리적 연결을 의미합니다. 주로 외래 키(Foreign Key)를 통해 구현되며, 이는 뒤에서 자세히 다루겠습니다. 테이블 간 관계의 주요 유형으론 다음과 같은것이 있습니다.
1. 일대일(One-to-One) 관계 -> 1:1 로 많이 표현
2. 일대다(One-to-Many) 관계 -> 1:N 으로 많이 표현
3. 다대다(Many-to-Many) 관계 -> N:M 으로 많이 표현

1:1 관계와 1:N 관계는 일상적인 생활에서 많이 사용되고 실제로도 데이터베이스를 설계할 때 가장 많이 사용되는 관계라서 이해하기 쉽지만, N:M 관계는 조금 복잡하므로 주의가 필요합니다. N:M 관계는 기본적으로 1:N 관계의 조합으로 이해할 수 있습니다. 양쪽 테이블이 서로 1:N 관계를 가지고 있을 때, 이를 N:M 관계로 표현할 수 있습니다.

예를 들어 학생과 과목 테이블이 있을 때, 한 학생은 여러 과목을 수강할 수 있고, 한 과목은 여러 학생이 수강할 수 있습니다. 이러한 관계를 N:M 관계로 표현할 수 있습니다.

**EXAMPLE**
1. One-to-One (1:1): 국가 - 수도는 일대일 관계입니다. 한 국가는 하나의 수도를 가지며, 한 수도는 한 국가에 속합니다.
2. One-to-Many (1:N): 국가 - 도시는 일대다 관계입니다. 한 국가는 여러 도시를 가질 수 있지만, 한 도시는 한 국가에 속합니다.
3. Many-to-Many (N:M): 학생 - 수강과목은 다대다 관계입니다. 한 학생은 여러 과목을 수강할 수 있고, 한 과목은 여러 학생이 수강할 수 있습니다.

**추가 설명(지금 당장 이해할 필요는 없지만, 나중에 테이블을 설계 시 도움이 될 것입니다.)**
1. 1:1 관계는 때때로 두 개의 테이블을 하나로 합칠 수 있는지 고려해볼 필요가 있습니다. 하지만 데이터의 특성이나 접근 패턴에 따라 분리가 필요한 경우도 있습니다.
2. 1:N 관계는 가장 흔한 관계 유형으로, 외래 키를 통해 쉽게 구현할 수 있습니다.
3. N:M 관계를 구현할 때는 일반적으로 중간 테이블(연결 테이블)을 사용하여 두 개의 1:N 관계로 분해합니다. 이 중간 테이블은 양쪽 테이블의 키를 외래 키로 가집니다.


이러한 관계들을 적절히 사용하면 데이터의 중복을 줄이고, 데이터 일관성을 유지하며, 효율적인 데이터 검색이 가능해집니다.

***

# Key

| id | name | age | email  |
|----|------|-----|--------|
| 1  | Alice| 24  |email@1 |
| 2  | Bob  | 25  |email@2 |
| 3  | Chris| 23  |email@3 |
| 4  | Alice| 22  |email@4 |

키(Key)는 테이블에서 <R>특정 튜플을 고유하게 식별하기 위해 사용되는 속성</R> 또는 속성의 집합입니다. 키는 데이터베이스의 무결성을 유지하는 데 중요한 역할을 합니다. 위의 예에서는 `id`와 `email`이 키가 될 수 있습니다. 보통 Key는 DBMS가 자동으로 관리하지만, 때로는 개발자가 직접 지정하기도 합니다.

## Key의 특성
1. 유일성 (Uniqueness): 키는 테이블 내에서 유일해야 합니다. 즉, 동일한 키 값을 가진 튜플이 두 개 이상 존재해서는 안 됩니다.
2. 최소성 (Minimality): 키는 최소한의 속성으로 구성되어야 합니다. 즉, 불필요한 속성이 포함되어서는 안 됩니다.

1. key:
    * 가끔 속성을 합쳐서 키를 만들기도 한다.
    * 반반드시 키를 가지고 있어야 한다.
2. 무결성 제약약조건: 결함이 없없도록 붙여주는 조건
3.

## Key의종류
테이블에는 중복된 튜플을 허용하지 않도록 하나 이상의 키가 있어야 합니다. 키는 여러 개일 수 있지만 실제로 동작하는 키는 하나입니다. 가장 중요한 키의 종류는 <R>기본키</R>와 <B>외래키</B>입니다. 그 이외의 키들은 별로 의미도 없고 중요성도 매우 낮습니다.

### 기본키(Primry key)
테이블에서 각 레코드를 고유하게 식별할 수 있는 속성 또는 속성의 집합을 키(Key)라고 합니다. 이러한 키 중에서 <R>테이블을 대표하는 고유 식별자로 선택된 키</R>를 기본키라고 합니다. 기본키는 DBMS에 의해 자동으로 지정돼게 하거나, 데이터베이스 관리자가 중요하다고 판단되는 속성을 선택하여 지정할 수 있습니다.

#### 기본키 선정 시 고려사항
1. NULL 값을 허용하지 않습니다.
2. 값이 변경되지 않아야 합니다 (불변성).
3. 단순하고 짧은 속성을 사용하는 것이 좋습니다.
4. 향후 데이터 증가에도 대응할 수 있어야 합니다.

### 슈퍼키(Super key)
<R>튜플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합입니다.</R> 예시 테이블에서는 `id`, `email`, `(id, email)`, `(id, name, age)` 등이 슈퍼키가 될 수 있습니다. 슈퍼키는 최소성을 만족하지 않을 수 있습니다.


### 후보키(Candidate key)
테이블에서 각 행을 유일하게 식별할 수 있는 속성의 최소 집합입니다. 슈퍼키 중에서 각 행을 유일하게 식별 가능한 `(id, email)`이 후보키 입니다. 후보키는 기본키가 될수 있는 후보들이며 자연스럽게 기본키와 마찬가지로 유일일성과 최소성을 동시에 만족해야 합니다.


### 대체키(Alternate key)
대체키(alternate key)는 기본키로 선정되지 않은 후보키를 말합니다.

### 대리키(Surrogate key)
인조키라고도 합니다. 예시 테이블의 id처럼 의미를 갖지 않고 오로지 튜플을 식별하기 위한 용도로만 사용되는 키입니다. 주로 DBMS가 자동으로 생성하며, 개인정보 보호 등의 이유로 자주 사용됩니다.


### 외래키(Foreign key)
외래키는 데이터베이스에서 가장 중요한 개념 중 하나로, <R>테이블 간의 관계를 표현</R>하는 핵심 요소입니다.

#### 외래키의 특징
1. 관계 표현: 외래키는 한 테이블의 필드(또는 필드 집합)가 다른 테이블의 기본키를 참조할 때 사용됩니다. 이를 통해 <R>테이블 간의 논리적 연결</R>을 만들 수 있습니다.
2. 이름의 유래: **Foreign**이라는 이름은 이 키가 **외부에서 빌려온 키**라는 개념에서 왔습니다. 즉, 다른 테이블의 키를 참조하기 때문에 **외래키**라고 부릅니다.
3. 유연한 규칙: 일반적인 키와 달리, 외래키는 고유성(uniqueness)을 요구하지 않습니다. 따라서 <R>중복된 값이나 NULL 값을 가질 수 있습니다</R>, 이름의 유래에서 살펴볼수 있듯이 사실 엄밀하게 따지면 키가 아니기 때문에 이러한 유연한 규칙이 적용됩니다.
4. 자기 참조: 외래키가 반드시 다른 테이블을 참조할 필요는 없습니다. 같은 테이블 내에서 자기 자신을 참조하는 경우도 있습니다. 이런 경우 보통 외래키로 NULL 값을 가집니다.

`Users` 테이블과 `Orders` 테이블이 있다고 가정해보겠습니다. `Orders` 테이블의 `user_id` 속성은 `Users` 테이블의 `id` 속성을 참조하고 있습니다. 이때 `Orders` 테이블의 `user_id` 속성은 외래키가 됩니다. 이 예시에서 `id`가 `1`인 `Users` 테이블의 `Alice`가 `Apple`을 주문했고, `id`가 `2`인 `Bob`이 `Banana`를 주문했음을 알 수 있습니다.

**Users**
| id | name | age | email  |
|----|------|-----|--------|
| 1  | Alice| 24  |email@1 |
| 2  | Bob  | 25  |email@2 |
| 3  | Chris| 23  |email@3 |
| 4  | Alice| 22  |email@4 |

**Orders**
| id | user_id | product | price |
|----|---------|---------|-------|
| 1  | 1       | Apple   | 1000  |
| 2  | 2       | Banana  | 2000  |
| 3  | 1       | Orange  | 1500  |
| 4  | 3       | Grape   | 3000  |

***













# 무무결성 제약 조건
전부 키와 관계가 있다.

무결성 제약약조건: 결함이 없없도록 붙여주는 조건

관계형 모델엔 3가지가 있다.

* 무결성: 결험이 없다, 즉 DB에 저장된 데이터늬 일관성과 정확성을 지키는것을 말함.
* 도메인 무결성 제약 조건
    * ex) 학번은 Integer다, 문자열이면 안안됀다.
* 개체 무결성 제약약조건, 다른말말로 기본키 제약 조조건이라 한한다.
    * ex) 반드시 기본키를 지정해야 한다는 조건
* 참조 무결성 제약약조건, 관계에 관한 조건이다.
    * ex) 학생 테이블과 학과 테이블이 있다 가정 했을을때, 학생 테이블에서 학과 테이블을 참조할때, 바로 학과명으로 참조하는는게 아닌, 학과 테이블의 기본키인 학과 코드로 참조한다.
        * 이때 참조하는 기본키의 타입이 같아야 한다.
        * Insert: 부모에 삽입할땐 별다른 제약조건이 없다. 하지만 자식에 삽입할때 참조받는 테이블블에 외래키는 부모 테이블의 키가 있는거로 삽입해야 한다.
        * Dlete: 자식은 마음대로 삭제해도 됀다. 하지만 부모 릴레이션션을 삭제할때는 문제가 됀다. 예를들어, 체유유학과가 사라졌을때, 자식 테이블의 체육학과과를 어떻게 할지에 대한거다. 4가지가 있있다. 부모가 삭제돼면 자식도 전부 삭제, 부모가 삭제돼면 디폴트 값으로 바꾼다(예를들어 무전공), 참조돼는 자식이 있으면 애초에 삭제를 못하게, 자식을 NULL로 바꾼다.
        * 이것들은 테이블을 생성할때 결정할 수 있다. 프로그래밍만 잘하면 DBMS가 알아서 해준다는 뜻
        * 수정: 부모키가 변경경돼면 자식도 일괄 변경, 자식 테이블은 부ㅗ 테능블의 키로만 수정 가능


이러한 조건건들은 프로로그래밍을 통해 작성한다, 잘 지켜졌는지에 대한 검산은 DBMS가 해해준다.



